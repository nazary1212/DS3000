import time
from Motor import *
from servo import *
from Ultrasonic import *
from LED import *
import RPi.GPIO as GPIO

# Define GPIO pins for the infrared sensors
IR01 = 14
IR02 = 15
IR03 = 23

# Set up GPIO mode and pins for infrared sensors
GPIO.setmode(GPIO.BCM)
GPIO.setup(IR01, GPIO.IN)  # Left infrared sensor
GPIO.setup(IR02, GPIO.IN)  # Middle infrared sensor
GPIO.setup(IR03, GPIO.IN)  # Right infrared sensor

class Ultrasonic:
    def __init__(self):
        GPIO.setwarnings(False)
        self.trigger_pin = 27  # Pin for triggering the ultrasonic sensor
        self.echo_pin = 22     # Pin for receiving the echo
        self.MAX_DISTANCE = 300  # Maximum distance the sensor can measure in cm
        self.timeOut = self.MAX_DISTANCE * 60  # Timeout based on max distance
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.trigger_pin, GPIO.OUT)  # Set trigger pin as output
        GPIO.setup(self.echo_pin, GPIO.IN)     # Set echo pin as input

    # Measure the pulse time for the ultrasonic sensor
    def pulseIn(self, pin, level, timeOut):
        t0 = time.time()
        while (GPIO.input(pin) != level):  # Wait for the level to change
            if ((time.time() - t0) > timeOut * 0.000001):  # Check for timeout
                return 0
        t0 = time.time()
        while (GPIO.input(pin) == level):  # Wait for the level to change back
            if ((time.time() - t0) > timeOut * 0.000001):  # Check for timeout
                return 0
        pulseTime = (time.time() - t0) * 1000000  # Calculate pulse time in microseconds
        return pulseTime

    # Get the distance from the ultrasonic sensor
    def get_distance(self):
        distance_cm = [0, 0, 0, 0, 0]  # List to store multiple distance readings
        for i in range(5):  # Take 5 readings for accuracy
            GPIO.output(self.trigger_pin, GPIO.HIGH)
            time.sleep(0.00001)  # Short pulse to trigger the sensor
            GPIO.output(self.trigger_pin, GPIO.LOW)
            pingTime = self.pulseIn(self.echo_pin, GPIO.HIGH, self.timeOut)
            distance_cm[i] = pingTime * 340.0 / 2.0 / 10000.0  # Convert time to distance
        distance_cm = sorted(distance_cm)  # Sort readings to get a median value
        return int(distance_cm[2])  # Return the middle value for better accuracy

class Line_Tracking:
    def __init__(self):
        self.PWM = Motor()  # Motor control object
        self.ultrasonic = Ultrasonic()  # Ultrasonic sensor object
        self.default_speed = 800  # Default speed of the robot
    
    def set_led_color(self, red, green, blue):
        """Set LED color (red, green, blue)."""
        self.led.ledIndex(0x01, red, green, blue)  # LED 1 for state indication

    # Function to control motor movement based on sensor inputs
    def run_motor(self, L, M, R):
        if M < 15:  # If the middle sensor detects an obstacle (very close)
            self.PWM.setMotorModel(0, 0, 0, 0)  # Stop completely
            self.set_led_color(255,0,0)
        
        # Handle obstacle directly ahead (all sensors detect close proximity)
        elif L < 30 and M < 30 and R < 30:
            self.PWM.setMotorModel(-1000, -1000, -1000, -1000)  # Reverse
            self.set_led_color(0,255,0)
            time.sleep(0.2)
            flag = False # Determines if the bot turns left or right
            if L < R:  # If the left sensor detects an obstacle first
                self.PWM.setMotorModel(1000, 1000, -1000, -1000)  # Turn right
                self.set_led_color(0,255,0)
            else:  # If the right sensor detects an obstacle first
                self.PWM.setMotorModel(-1000, -1000, 1000, 1000)  # Turn left
                self.set_led_color(0,255,0)
                flag = True
            time.sleep(0.5)

            # Check if tape is detected again
            while True:
                if M > 30:  # If the middle sensor sees the line
                    self.PWM.setMotorModel(1000,1000,1000,1000)
                L, M, R = self.get_line_sensor_values()  # Get updated sensor values
                if L < 15 or M < 15 or R < 15:  # If any sensor detects an obstacle again
                    if flag == False: # and it turned right, turn left then  continue to follow the line
                        self.PWM.setMotorModel(-1000, -1000, 1000, 1000)  # Turn left
                        self.set_led_color(0,255,0)
                        time.sleep(0.2)
                        self.PWM.setMotorModel(self.default_speed, self.default_speed, self.default_speed, self.default_speed)
                        self.set_led_color(0,255,0)
                        time.sleep(0.3)
                    else:
                        self.PWM.setMotorModel(1000, 1000, -1000, -1000) 
                        self.set_led_color(0,255,0)
                        time.sleep(0.2)
                        self.PWM.setMotorModel(self.default_speed, self.default_speed, self.default_speed, self.default_speed)
                        time.sleep(0.3)
                    break
                else:
                    self.PWM.setMotorModel(self.default_speed, self.default_speed, self.default_speed, self.default_speed)
                    time.sleep(0.2)

            self.PWM.setMotorModel(0, 0, 0, 0)  # Stop the motors
            self.set_led_color(255,0,0)
            time.sleep(0.2)

        # Handle left obstacle
        elif L < 30 and M < 30:
            self.PWM.setMotorModel(1500, 1500, -1500, -1500)  # Turn right slightly
            self.set_led_color(0,255,0)
            time.sleep(0.2)

            while True:
                if M > 30:  # If the middle sensor sees the line
                    self.PWM.setMotorModel(-1500, -1500, 1500, 1500)
                    self.set_led_color(0,255,0)
                    time.sleep(0.3)
                
                L, M, R = self.get_line_sensor_values()
                if L < 15 or M < 15 or R < 15:  # If any sensor detects an obstacle again
                    self.PWM.setMotorModel(1500, 1500, -1500, -1500)  # Turn right slightly
                    self.set_led_color(0,255,0)
                    break
                else:
                    self.PWM.setMotorModel(self.default_speed, self.default_speed, self.default_speed, self.default_speed)  # Continue veering right
                    self.set_led_color(0,255,0)
                time.sleep(0.2)

            self.PWM.setMotorModel(0, 0, 0, 0)
            self.set_led_color(255,0,0)
            time.sleep(0.2)

        # Handle right obstacle
        elif R < 30 and M < 30:
            self.PWM.setMotorModel(-1500, -1500, 1500, 1500)  # Turn left slightly
            self.set_led_color(0,255,0)
            time.sleep(0.2)

            while True:
                if M > 30:  # If the middle sensor sees the line
                    self.PWM.setMotorModel(-1500, -1500, 1500, 1500)
                    self.set_led_color(0,255,0)
                    time.sleep(0.3)
                
                L, M, R = self.get_line_sensor_values()
                if L < 15 or M < 15 or R < 15:  # If any sensor detects an obstacle again
                    self.PWM.setMotorModel(-1500, -1500, 1500, 1500)  # Turn left slightly
                    self.set_led_color(0,255,0)
                    time.sleep(0.2)
                    break
                else:
                    self.PWM.setMotorModel(self.default_speed, self.default_speed, self.default_speed, self.default_speed)  # Continue veering left
                    self.set_led_color(0,255,0)
                time.sleep(0.2)

            self.PWM.setMotorModel(0, 0, 0, 0)
            time.sleep(0.2)

        # If no obstacles are detected, continue moving forward following the tape
        else:
            self.PWM.setMotorModel(self.default_speed, self.default_speed, self.default_speed, self.default_speed)
            
    # Function to track the line using infrared sensors
    def line_tracking_logic(self):
        self.LMR = 0x00  # Initialize variable to store sensor states
        if GPIO.input(IR01):  # Check if left infrared sensor is triggered
            self.LMR |= 4
        if GPIO.input(IR02):  # Check if middle infrared sensor is triggered
            self.LMR |= 2
        if GPIO.input(IR03):  # Check if right infrared sensor is triggered
            self.LMR |= 1

        # Motor control based on infrared sensor readings
        if self.LMR == 2:  # If the middle sensor sees the line
            self.PWM.setMotorModel(self.default_speed, self.default_speed, self.default_speed, self.default_speed)  # Move forward
        elif self.LMR == 4:  # If the left sensor sees the line
            self.PWM.setMotorModel(-1500, -1500, 2500, 2500)  # Turn left
        elif self.LMR == 6:  # If both left and middle sensors see the line
            self.PWM.setMotorModel(-2000, -2000, 4000, 4000)  # Sharp left turn
        elif self.LMR == 1:  # If the right sensor sees the line
            self.PWM.setMotorModel(2500, 2500, -1500, -1500)  # Turn right
        elif self.LMR == 3:  # If both right and middle sensors see the line
            self.PWM.setMotorModel(4000, 4000, -2000, -2000)  # Sharp right turn
        else:
            self.PWM.setMotorModel(self.default_speed, self.default_speed, self.default_speed, self.default_speed)  # Default forward

    # Main function to run the logic
    def run(self):
        while True:
            distance = self.ultrasonic.get_distance()  # Get distance from ultrasonic sensor
            if distance < 15:  # If an obstacle is detected within 15 cm
                self.run_motor()  # Stop the robot
            else:
                self.line_tracking_logic()  # Continue line tracking when no obstacle

# Main program logic
if __name__ == '__main__':
    print('Program is starting...')
    infrared = Line_Tracking()
    try:
        infrared.run()
    except KeyboardInterrupt:
        # Stop the motors and clean up GPIO settings on exit
        infrared.PWM.setMotorModel(0, 0, 0, 0)
        GPIO.cleanup()